{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/CryptoSavingVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./interfaces/ITellor.sol\";\n\n/**\n * @title CryptoSavingsVault\n * @dev Simple ETH savings vault with per-user simple interest.\n *      APR dynamically changes based on ETH/USD price from the Tellor oracle.\n *\n * Logic:\n *  - If ETH < $3000 → APR = 6%\n *  - If ETH ≥ $3000 → APR = 3%\n *\n *  APR is in basis points:\n *      600 → 6%\n *      300 → 3%\n *\n *  Simple Interest Formula:\n *      interest = principal * aprBps * timeElapsed / (365 days * 10000)\n */\ncontract CryptoSavingsVault is ReentrancyGuard {\n    // ============ State Variables ============\n\n    /// @notice principal staked per user (in wei)\n    mapping(address => uint256) public balances;\n\n    /// @notice timestamp when user last updated stake (for interest calculation)\n    mapping(address => uint256) public stakeTimestamps;\n\n    /// @notice interest accumulated but not yet withdrawn (in wei)\n    mapping(address => uint256) public accruedInterest;\n\n    /// @notice total ETH staked in the vault (principal only)\n    uint256 public totalStaked;\n\n    /// @notice Tellor oracle address\n    address public tellorOracle;\n\n    /// @notice APR when ETH < $3000 (6%)\n    uint256 public constant HIGH_APR = 600;\n\n    /// @notice APR when ETH >= $3000 (3%)\n    uint256 public constant LOW_APR = 300;\n\n    /// @notice Basis points denominator\n    uint256 public constant BPS_DENOM = 10000;\n\n    /// @notice Threshold for switching APR (18 decimals)\n    uint256 public constant ETH_THRESHOLD = 3000e18;\n\n    /// @notice Tellor query id for ETH/USD\n    bytes32 public constant ETH_QUERY_ID = keccak256(\"ETH/USD\");\n\n    // ============ Events ============\n\n    event Staked(address indexed user, uint256 amount, uint256 timestamp);\n    event Withdrawn(address indexed user, uint256 principal, uint256 interest, uint256 timestamp);\n\n    // ============ Constructor ============\n\n    constructor(address _tellorOracle) {\n        tellorOracle = _tellorOracle;\n    }\n\n    // ============ Core Functions ============\n\n    /**\n     * @notice Stake ETH into the vault.\n     * Moves any pending interest into accruedInterest & resets timestamp.\n     */\n    function stake() public payable nonReentrant {\n        require(msg.value > 0, \"Amount must be > 0\");\n\n        // If user already staked, add pending interest to accrued pool\n        if (balances[msg.sender] > 0 && stakeTimestamps[msg.sender] != 0) {\n            uint256 pending = _calculatePendingInterest(msg.sender);\n            if (pending > 0) {\n                accruedInterest[msg.sender] += pending;\n            }\n        }\n\n        // Increase principal & update timestamp\n        balances[msg.sender] += msg.value;\n        stakeTimestamps[msg.sender] = block.timestamp;\n        totalStaked += msg.value;\n\n        emit Staked(msg.sender, msg.value, block.timestamp);\n    }\n\n    /**\n     * @notice Withdraw principal + proportional simple interest.\n     */\n    function withdraw(uint256 amount) external nonReentrant {\n        require(amount > 0, \"Amount must be > 0\");\n        uint256 principal = balances[msg.sender];\n        require(principal >= amount, \"Insufficient balance\");\n\n        // Calculate total interest (accrued + pending)\n        uint256 pending = _calculatePendingInterest(msg.sender);\n        uint256 totalInterestAvailable = accruedInterest[msg.sender] + pending;\n\n        // User withdraws interest proportional to the amount withdrawn\n        uint256 interestForWithdraw = 0;\n        if (totalInterestAvailable > 0 && principal > 0) {\n            interestForWithdraw = (totalInterestAvailable * amount) / principal;\n        }\n\n        // Update bookkeeping\n        balances[msg.sender] = principal - amount;\n        totalStaked -= amount;\n\n        uint256 remainingInterest = totalInterestAvailable - interestForWithdraw;\n        accruedInterest[msg.sender] = remainingInterest;\n\n        // Reset timestamp for remaining principal\n        if (balances[msg.sender] > 0) {\n            stakeTimestamps[msg.sender] = block.timestamp;\n        } else {\n            stakeTimestamps[msg.sender] = 0;\n        }\n\n        // Pay ETH\n        uint256 payout = amount + interestForWithdraw;\n        (bool sent, ) = msg.sender.call{ value: payout }(\"\");\n        require(sent, \"ETH transfer failed\");\n\n        emit Withdrawn(msg.sender, amount, interestForWithdraw, block.timestamp);\n    }\n\n    // ============ Oracle-Based APR Logic ============\n\n    /**\n     * @notice Return current APR in basis points depending on ETH price.\n     */\n    function getCurrentAPR() public view returns (uint256) {\n        uint256 ethPrice = getETHPrice();\n        return (ethPrice < ETH_THRESHOLD) ? HIGH_APR : LOW_APR;\n    }\n\n    /**\n     * @notice Get ETH/USD price from Tellor (18 decimals).\n     * Fallback → threshold (forces LOW_APR).\n     */\n    function getETHPrice() public view returns (uint256) {\n        if (tellorOracle == address(0)) return ETH_THRESHOLD;\n\n        try ITellor(tellorOracle).getCurrentValue(ETH_QUERY_ID) returns (\n            bool ifRetrieve,\n            bytes memory value,\n            uint256 /*timestamp*/\n        ) {\n            if (!ifRetrieve || value.length == 0) return ETH_THRESHOLD;\n\n            uint256 decoded = abi.decode(value, (uint256));\n            if (decoded == 0) return ETH_THRESHOLD;\n\n            return decoded;\n        } catch {\n            return ETH_THRESHOLD;\n        }\n    }\n\n    // ============ View Helpers ============\n\n    function calculateInterest(address user) public view returns (uint256) {\n        return accruedInterest[user] + _calculatePendingInterest(user);\n    }\n\n    function getTotalBalance(address user) external view returns (uint256) {\n        return balances[user] + calculateInterest(user);\n    }\n\n    // ============ Internal ============\n\n    function _calculatePendingInterest(address user) internal view returns (uint256) {\n        uint256 principal = balances[user];\n        if (principal == 0) return 0;\n\n        uint256 ts = stakeTimestamps[user];\n        if (ts == 0) return 0;\n\n        uint256 dt = block.timestamp - ts;\n        if (dt == 0) return 0;\n\n        uint256 aprBps = getCurrentAPR();\n\n        uint256 numerator = principal * aprBps * dt;\n        uint256 denom = 365 days * BPS_DENOM;\n\n        return numerator / denom;\n    }\n\n    // ============ Admin ============\n\n    function setTellorOracle(address _tellor) external {\n        tellorOracle = _tellor;\n    }\n\n    // ============ Fallback ============\n\n    receive() external payable {\n        stake();\n    }\n}\n"
    },
    "contracts/interfaces/ITellor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title ITellor\n * @dev Simplified Tellor oracle interface for reading data\n * This is a minimal interface for the bootcamp project\n * Full Tellor docs: https://docs.tellor.io\n */\ninterface ITellor {\n    /**\n     * @dev Retrieve value from oracle based on queryId\n     * @param _queryId The ID of the data requested\n     * @param _timestamp The timestamp to retrieve data from\n     * @return _value The value retrieved\n     * @return _timestampRetrieved The timestamp when data was retrieved\n     */\n    function getDataBefore(bytes32 _queryId, uint256 _timestamp)\n        external\n        view\n        returns (bytes memory _value, uint256 _timestampRetrieved);\n\n    /**\n     * @dev Get the latest value for a queryId\n     * @param _queryId The ID of the data requested\n     * @return _ifRetrieve Whether the value was successfully retrieved\n     * @return _value The value retrieved\n     * @return _timestampRetrieved The timestamp of the value\n     */\n    function getCurrentValue(bytes32 _queryId)\n        external\n        view\n        returns (bool _ifRetrieve, bytes memory _value, uint256 _timestampRetrieved);\n}"
    },
    "contracts/mocks/TellorMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title TellorMock\n * @dev Minimal Tellor oracle mock for tests.\n *      Returns a stored price and timestamp.\n */\ncontract TellorMock {\n    uint256 public price;\n\n    constructor(uint256 _price) {\n        price = _price;\n    }\n\n    function setPrice(uint256 _price) external {\n        price = _price;\n    }\n\n    // This matches the signature expected by ITellor in your vault.\n    function getCurrentValue(bytes32) external view returns (bool, bytes memory, uint256) {\n        return (true, abi.encode(price), block.timestamp);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}